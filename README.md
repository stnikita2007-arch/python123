Блочная (корзинная) сортировка
Определение: Блочная сортировка (bucket sort) — это алгоритм, который распределяет
элементы исходного массива на несколько блоков (корзин) в зависимости от диапазона их
значений. После этого каждая корзина сортируется отдельно (либо тем же методом
рекурсивно, либо другим алгоритмом, например, вставками), и отсортированные корзины
объединяются обратно в один массив.

# Оператор 1: Создание пустых корзин
buckets = [[] for _ in range(n)]
# Оператор 2: Распределение элементов по корзинам
for num in arr:
# Оператор 3: Сортировка каждой корзины
for bucket in buckets:
# Оператор 4: Объединение корзин
result.extend(bucket)


Временная сложность:
Лучший случай: O(n + k) - когда элементы равномерно распределены
Средний случай: O(n + k)
Худший случай: O(n²) - когда все элементы попадают в одну корзину
Объяснение: Сложность зависит от распределения элементов и алгоритма сортировки корзин.
2. Блинная Сортировка
Определение: Блинная сортировка (pancake sort) — это метод, основанный на операции
переворота (reversal) части массива. В отличие от большинства алгоритмов, которые
обменивают соседние элементы или выбирают опорные точки, здесь единственная
разрешённая операция — переворот префикса массива до выбранного индекса.
# Оператор 1: Переворот массива до позиции i
while start < i:
# Оператор 2: Поиск максимального элемента
for curr_size in range(n, 1, -1):
# Оператор 3: Переворот до максимального элемента
if max_idx != curr_size - 1:
Временная сложность: O(n²)
Объяснение: Для каждого элемента выполняем O(n) операций поиска максимума и O(n) операций переворота.
Сортировка Бусинами
Определение: Сортировка бусинами (bead sort), также известная как гравитационная
сортировка, моделирует естественное поведение бусин, падающих вниз под действием
гравитации.
# Оператор 1: Находим максимальный элемент
max_val = max(arr)
# Оператор 2: Создаем "абак" с бусинами
beads = [[0] * max_val for _ in range(len(arr))]
# Оператор 3: Размещаем бусины
for i in range(len(arr)):
        for j in range(arr[i]):
# Оператор 4: Симуляция падения бусин
for j in range(max_val):
        sum_beads = 0
        for i in range(len(arr)):
# Оператор 5: Бусины падают вниз
for i in range(len(arr) - sum_beads, len(arr)):
# Оператор 6: Преобразуем обратно в числа
    result = [sum(row) for row in beads]
Временная сложность: O(S), где S - сумма всех элементов
Объяснение: Время зависит от количества бусин, которые нужно обработать.
Поиск Скачками
Определение:
Поиск скачками — это оптимизация линейного поиска для отсортированных массивов, при
которой алгоритм «прыгает» через определённое число элементов (обычно через n), чтобы
быстро сузить диапазон поиска, а затем выполняет линейный поиск внутри найденного
диапазона.
# Оператор 1: Определение размера прыжка
    step = int(math.sqrt(n))
# Оператор 2: Поиск блока, содержащего элемент
    while arr[min(step, n) - 1] < x:
# Оператор 3: Линейный поиск в найденном блоке
    while arr[prev] < x:
# Оператор 4: Проверка найденного элемента
    if arr[prev] == x:
Временная сложность: O(√n)
Объяснение: Оптимальный размер прыжка - √n, что минимизирует общее количество сравнений.
Экспоненциальный Поиск
Определение:
Экспоненциальный поиск сочетает идеи последовательного и бинарного поиска, позволяя
быстро определить диапазон, в котором может находиться искомое значение, а затем
применяет двоичный поиск в этом диапазоне.

# Оператор 1: Поиск диапазона
    if arr[0] == x:
# Оператор 2: Бинарный поиск в найденном диапазоне
    return binary_search(arr, i // 2, min(i, n - 1), x)
Временная сложность: O(log n)
Объяснение: Сначала находим диапазон за O(log n), затем бинарный поиск за O(log n).
Тернарный Поиск
Определение:
Тернарный поиск — это метод деления диапазона поиска на три части (в отличие от двух в
бинарном) и рекурсивного сужения диапазона до тех пор, пока не будет найден элемент или
экстремум функции (в зависимости от задачи).
# Оператор 1: Вычисление двух точек деления
        mid1 = left + (right - left) // 3
        mid2 = right - (right - left) // 3
# Оператор 2: Проверка точек деления
        if arr[mid1] == x:
        if arr[mid2] == x:
# Оператор 3: Рекурсивный поиск в одной из трех частей
        if x < arr[mid1]:
        elif x > arr[mid2]:

Временная сложность: O(log₃n)
Объяснение: На каждой итерации область поиска уменьшается в 3 раза.







