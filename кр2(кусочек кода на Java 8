public static List<int[]> aStar(int[][] grid) {
    int n = grid.length, m = grid[0].length;
    PriorityQueue<Node> open = new PriorityQueue<>();
    Set<String> closed = new HashSet<>();
    open.add(new Node(0, 0, 0, heuristic(0, 0, n-1, m-1)));
    while (!open.isEmpty()) {
        Node curr = open.poll();
        // ДОПИСАТЬ: генерация соседей, обновление open/closed
    }
    return path;
}

import java.util.*;

public class AStarPathfinding {
    
    static class Node implements Comparable<Node> {
        int x, y;
        int gCost; // стоимость от начала
        int hCost; // эвристическая стоимость до цели
        int fCost; // общая стоимость (g + h)
        Node parent;
        
        Node(int x, int y, int gCost, int hCost) {
            this.x = x;
            this.y = y;
            this.gCost = gCost;
            this.hCost = hCost;
            this.fCost = gCost + hCost;
        }
        
        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.fCost, other.fCost);
        }
        
        @Override
        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            Node node = (Node) obj;
            return x == node.x && y == node.y;
        }
        
        @Override
        public int hashCode() {
            return Objects.hash(x, y);
        }
    }
    
    public static List<int[]> aStar(int[][] grid) {
        int n = grid.length, m = grid[0].length;
        
        // Проверка на препятствия в начальной и конечной точках
        if (grid[0][0] == 1 || grid[n-1][m-1] == 1) {
            return new ArrayList<>();
        }
        
        PriorityQueue<Node> open = new PriorityQueue<>();
        Set<String> closed = new HashSet<>();
        
        // Начальный узел
        open.add(new Node(0, 0, 0, heuristic(0, 0, n-1, m-1)));
        
        int[][] directions = {{0,1}, {1,0}, {0,-1}, {-1,0}}; // вправо, вниз, влево, вверх
        
        while (!open.isEmpty()) {
            Node curr = open.poll();
            
            // Если достигли цели
            if (curr.x == n-1 && curr.y == m-1) {
                return reconstructPath(curr);
            }
            
            String currKey = curr.x + "," + curr.y;
            closed.add(currKey);
            
            // Генерация соседей
            for (int[] dir : directions) {
                int newX = curr.x + dir[0];
                int newY = curr.y + dir[1];
                
                // Проверка границ и препятствий
                if (newX < 0 || newX >= n || newY < 0 || newY >= m || grid[newX][newY] == 1) {
                    continue;
                }
                
                String neighborKey = newX + "," + newY;
                if (closed.contains(neighborKey)) {
                    continue;
                }
                
                int newGCost = curr.gCost + 1;
                int newHCost = heuristic(newX, newY, n-1, m-1);
                Node neighbor = new Node(newX, newY, newGCost, newHCost);
                neighbor.parent = curr;
                
                // Проверяем, есть ли уже этот узел в open с худшей стоимостью
                boolean shouldAdd = true;
                for (Node openNode : open) {
                    if (openNode.x == newX && openNode.y == newY && openNode.fCost <= neighbor.fCost) {
                        shouldAdd = false;
                        break;
                    }
                }
                
                if (shouldAdd) {
                    open.add(neighbor);
                }
            }
        }
        
        return new ArrayList<>(); // путь не найден
    }
    
    private static int heuristic(int x1, int y1, int x2, int y2) {
        // Манхэттенское расстояние
        return Math.abs(x1 - x2) + Math.abs(y1 - y2);
    }
    
    private static List<int[]> reconstructPath(Node goal) {
        List<int[]> path = new ArrayList<>();
        Node current = goal;
        
        while (current != null) {
            path.add(0, new int[]{current.x, current.y});
            current = current.parent;
        }
        
        return path;
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        System.out.println("Введите размеры сетки (n m):");
        int n = scanner.nextInt();
        int m = scanner.nextInt();
        
        int[][] grid = new int[n][m];
        
        System.out.println("Введите сетку (0 - свободно, 1 - препятствие):");
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                grid[i][j] = scanner.nextInt();
            }
        }
        
        List<int[]> path = aStar(grid);
        
        if (path.isEmpty()) {
            System.out.println("Путь не найден!");
        } else {
            System.out.println("Найденный путь:");
            for (int[] point : path) {
                System.out.println("(" + point[0] + ", " + point[1] + ")");
            }
            System.out.println("Длина пути: " + (path.size() - 1));
        }
        
        scanner.close();
    }
}

Пример работы программы

Входные данные:

text
Введите размеры сетки (n m):
4 4
Введите сетку (0 - свободно, 1 - препятствие):
0 0 0 0
0 1 1 0
0 1 0 0
0 0 0 0
Результат:

text
Найденный путь:
(0, 0)
(0, 1)
(0, 2)
(0, 3)
(1, 3)
(2, 3)
(3, 3)
Длина пути: 6
